
        List<String> key = new ArrayList<>(List.of("a", "b", "c", "d", "e"));

        Map<List<String>, String> map = new HashMap<>();
        map.put(key, "Hello");

        key.add("f");
        System.out.println(map.get(key));
        System.out.println(map);


		    public static void main(String[] args) {
        Map<Integer, List<Long>> input = new HashMap<>();
        input.put(1, Arrays.asList(0l, 1l, 2l));
        input.put(2, Arrays.asList(3l, 4l));

        Map<Long, Integer> output = input.entrySet().stream()
            .flatMap(entry -> entry.getValue().stream().map(value -> new long []{entry.getKey(), value}))
            .collect(Collectors.toMap(array -> array[1], array -> array[0]));

        System.out.println(output);// 0=1, 1=1, 2=1, 3=2, 4=2
    }

////////////////////////////////////////////////////////////////////////////////

String s = "a";
s.toUpperCase();
System.out.println(s);

////////////////////////////////////////////////////////////////////////////////

String a = "A1";
String b = new String("A1");
String c = "A" + "1";

System.out.println(a == b);// false
System.out.println(a == c);// true

////////////////////////////////////////////////////////////////////////////////
   /**
* Есть массив слов
* Написать функцию, которая определяет самый длинный общий префикс
* Пример:
* Массив array{"flower", "flow", "flight"}
* Самый длинный общий префикс -> "fl"
* Массив array {"dog","racecar","car"}
* Самый длинный общий префикс -> ""
*/

////////////////////////////////////////////////////////////////////////////////

Нужно написать метод, который переворачивает значение Integer:
120 -> 21
351 -> 153

public static int reverse(int i){
    StringBulderer number = new StringBuilder(String.valueOf(Math.abs(i)));
    return Integer.parseInt(number.reverse().toString());


}

////////////////////////////////////////////////////////////////////////////////

// задача А
// List<Integer> list = List.of(1, 2, 5, 3, 6, 2); // Результат: 2 2 6 1 3 5

public List<Integer>sortEvenAndOdd (List<Integer> list){

}

// задача Б
// Удалить все элементы меньше 3 не используя стримы

////////////////////////////////////////////////////////////////////////////////

реализовать пузырьковую сортировку

public class BubbleSort(){
    public static int[] sort (int[] array){ [1, 2, 4, 56, 13, 721, 0]

    }
}

////////////////////////////////////////////////////////////////////////////////

List.of("A1", "A2", "B1", "B2").stream()
     .peek(System.out::println)
     .sorted()
     .peek(System.out::println)
     .filter(it -> it.startsWith("A"))
     .forEach(System.out::println);
// A1 A2 B1 B2 A1 A1 A2 A2 B1 B2
////////////////////////////////////////////////////////////////////////////////

@RestController
@RequestMapping("/api/user")//
public class UserController {

    @Autowired
    private UserService userService;//

    private final ExecutorService executorService = Executors.newFixedThreadPool(5);
    private volatile int counter;

    @GetMapping("/{id}")
    public User getUser(@PathVariable String id) {
        executorService.submit(() -> {
            try {
                counter++;
                User userData = userService.getUserData(id);
                System.out.println("User Data retrieved: " + userData);//
            } catch (Exception e) {
                System.err.println("Error fetching user data.");//
            }
        });
        return userData;
    }
}

////////////////////////////////////////////////////////////////////////////////

@Service
@Req
public class UserService {

    private final UserRepository userRepository = new UserRepository();

    private final Map<String, User> cache = new HashMap<>();//

    @Cached
    public Optional<User> getUserData(String userId) {

        if (cache.containsKey(userId)) {
            return cache.get(userId);
        }
        Optional<User> user = userRepository.findById(userId);
        cache.put(userId, user);//
        return user;
    }
}

////////////////////////////////////////////////////////////////////////////////

/*
Необходимо реализовать класс, который умеет принимать элементы
и в любой момент времени возвращать N(capacity) наибольших уникальных элементов.
Если количество элементов помещенных в класс меньше N - то требуется организовать ожидание,
до тех пор пока не наберется N элементов
 */
public class TopNElementsCollection {

    public TopNElementsCollection(int capacity) {

    }

    public void push(int value) {

        }
    }

    public List<Integer> pull() throws InterruptedException {

    }
}

////////////////////////////////////////////////////////////////////////////////


//Код-ревью: что будет выведено в консоль ?

import java.util.concurrent.CompletableFuture;

public class Test {
    private Object object = new Object();

    public void print() throws InterruptedException {

        CompletableFuture.runAsync(() -> {
            synchronized (object) {
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("1");
            }
        });

        Thread.sleep(100);

        object = new Object();

        CompletableFuture.runAsync(() -> {
            synchronized (object) {
                System.out.println("2");
            }
        });

    }
}

////////////////////////////////////////////////////////////////////////////////

leet 1

/**
* Дан массив целых чисел nums и целое число target,
* нужно вернуть индексы двух чисел из массива таким образом,
* чтобы они в сумме давали target.
* Имеем в ввиду, что каждый набора входных данных будет только одно решение,
* и нельзя использовать один и тот же элемент дважды.
* Вы можете вернуть ответ в любом порядке.
*/

/**
* Пример 1:
* Входные данные: nums = [2,7,11,15], target = 9
* Выходные данные: [0,1]
* Объяснение: Поскольку nums[0] + nums[1] == 9, возвращаем [0, 1].
*
* Пример 2:
* Входные данные: nums = [3,2,4], target = 6
* Выходные данные: [1,2]
*
* Пример 3:
* Входные данные: nums = [3,3], target = 6
* Выходные данные: [0,1]
*/

class Solution {
    public int[] twoSum(int[] nums, int target) {

    }
}

////////////////////////////////////////////////////////////////////////////////

leet 2

/**
* Даны два непустых связанных списка, представляющих два положительных целых числа.
* Цифры хранятся в обратном порядке, и каждый из их узлов содержит одну цифру.
* Сложите два числа и верните сумму в виде связанного списка.
* Берём за основу, что два числа не содержат начальных нулей, кроме самого числа 0.
*/

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

    }
}

/**
* Пример 1:
* Входные данные: l1 = [2,4,3], l2 = [5,6,4]
* Выходные данные: [7,0,8]
* Объяснение: 342 + 465 = 807.
* {2} -> {4} -> {3}  +  {5} -> {6} -> {4}  =  {7} -> {0} -> {8}
*
* Пример 2:
* Входные данные: l1 = [0], l2 = [0]
* Выходные данные: [0]
* Объяснение: 0 + 0 = 0
*
* Пример 3:
* Входные данные: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
* Выходные данные: [8,9,9,9,0,0,0,1]
*/

////////////////////////////////////////////////////////////////////////////////

leet 3

/**
* Данa строка s, найте длину самой длинной подстроки (substring)
* без повторяющихся символов
*/

class Solution {
    public static int lengthOfLongestSubstring(String s) {
        Map<Integer, String> map = new TreeMap();
        String[] array = s.split("");
        String substr = "";
        Integer subcount = 0;
        for (int i = 0; i < array.length; i++) {
            if (!subtr.contains(array[i])) {
                sustr = subst + array[i];
                subcount++;
            } else {
                map.put(subcount, substr);
                subcount = 1;
                substr = array[i];
            }
        }

        return map.floor(INTEGER.MAX);

    }
}

/**
* Пример 1:
* Входные данные: s = "abcabcbb"
* Выходные данные: 3
* Объяснение: правильный ответ - "abc", с длиной равной 3.
*
* Пример 2:
* Входные данные: s = "bbbbb"
* Выходные данные: 1
* Объяснение: правильный ответ - "b", с длиной равной 1.
*
* Пример 3:
* Входные данные: s = "pwwkew"
* Выходные данные: 3
* Объяснение: правильный ответ - "wke", с длиной равной 3.
*
* Учтите, что ответ должен быть подстрокой(substring), "pwke" является subsequence, а не подстрокой.
*/

////////////////////////////////////////////////////////////////////////////////

leet 5

/**
* Дана String s, возвратите самую длинную палиндромную подстроку из s
*/

class Solution {
    public String longestPalindrome(String s) {

    }
}

/**
* Пример 1:
* Входные данные: s = "babad"
* Выходные данные: "bab"
* Объяснение: "aba" так же является правильным ответом.
*
* Пример 2:
* Входные данные: s = "cbbd"
* Выходные данные: "bb"
*/

////////////////////////////////////////////////////////////////////////////////

leet 7

/**
* Дано 32 битное signed целое число x, "разверните" число х в обратную сторону.
* Если развёрнутое число х имеет значение,
* выходящее за рамки 32 битного signed целого числа [-2e31, 2e31 - 1], тогда, возвратите 0.
*/

class Solution {
    public int reverse(int x) {

    }
}

/**
* Пример 1:
* Входные данные: x = 123
* Выходные данные: 321
*
* Пример 2:
* Входные данные: x = -123
* Выходные данные: -321
*
* Пример 3:
* Входные данные: x = 120
* Выходные данные: 21
*
* Ограничения:
*
* -231 <= x <= 231 - 1
*/



////////////////////////////////////////////////////////////////////////////////

leet 9

/**
* Дано целое число x, вернуть true если x является палиндромом, и false в ином случае.
*/

class Solution {
    public boolean isPalindrome(int x) {

    }
}

/**
* Пример 1:
* Входные данные: x = 121
* Выходные данные: true
* Объяснение: 121 читается как 121 слева направо и справа налево.
*
* Пример 2:
* Входные данные: x = -121
* Выходные данные: false
* Объяснение: Слева направо читается как -121.
* Справа налево превращается в 121-. И поэтому это не является палиндромом.
*
* Пример 3:
* Входные данные: x = 10
* Выходные данные: false
* Объяснение: Представляет собой 01 справа налево. И поэтому не является палиндромом.
*/

////////////////////////////////////////////////////////////////////////////////

leet 11

/**
* Дан целочисленный массив height длины n, представленный n -числом вертикальных линий,
* Найдите две линии, которые вместе с осью x образуют контейнер,
* таким образом, чтобы контейнер содержал наибольший объём жидкости.
* Верните максимальный объём жидкости, который может хранить контейнер.
* Учтите, что вы не можете наклонять контейнер.                            |
*/

class Solution {
    public int maxArea(int[] height) {

    }
}

/**
*       | int maxArea = 49  |
*       |```````````````````|```````|
*       |   |               |       |
*       |   |       |       |       |
*       |   |       |   |   |       |
*       |   |       |   |   |   |   |
*       |   |   |   |   |   |   |   |
*   |___|___|___|___|___|___|___|___|
*   1   8   6   2   5   4   8   3   7
*  [0] [1] [2] [3] [4] [5] [6] [7] [8]
*/

/**
* Входные данные: height = [1,8,6,2,5,4,8,3,7]
* Выходные данные: 49
* Объяснение: Показанные выше вертикальные линии представлены массивом [1,8,6,2,5,4,8,3,7].
* В этом случае максимальная площадь жидкости (секция ниже линии ``````````), которую может содержать контейнер, составляет 49.
*
* Example 2:
* Входные данные: height = [1,1]
* Выходные данные: 1
*
* Ограничения:
*
* n == height.length
* 2 <= n <= 10e5
* 0 <= height[i] <= 10e4
*/




////////////////////////////////////////////////////////////////////////////////

leet 12

// Дано целое число num, преобразуйте его в римское число.

class Solution {
    public String intToRoman(int num) {

    }
}

/**
* Семь различных символов представляющих Римские цифры с соответствующими значениями:
*
* Символ    Значение
* I        1
* V        5
* X        10
* L        50
* C        100
* D        500
* M        1000
*
* Римские цифры образуются путем добавления преобразований значений десятичных знаков от самого большого
* к самому низкому. Преобразование значения десятичного знака в римское число имеет следующие правила:
*
* Если значение не начинается с 4 или 9, выберите символ максимального значения,
* которое можно вычесть из ввода, добавьте этот символ к результату,
* вычтите его значение и преобразуйте остаток в римское число.
* Если значение начинается с 4 или 9, используйте субтрактивную форму,
* представляющую один символ, вычитаемый из следующего символа, например:
* 4 на 1 (I) меньше 5 (V) = IV,
* а 9 на 1 (I) меньше 10 (X) = IX.
*
* Используются только следующие субтрактивные формы:
*    4 (IV),
*    9 (IX),
*   40 (XL),
*   90 (XC),
*  400 (CD) и
*  900 (CM).
* ! Только степени 10 (I, X, C, M) можно добавлять последовательно не более 3 раз для представления кратных 10.
* ! Нельзя добавлять 5 (V), 50 (L) или 500 (D) более 1го раза.
* ! Если вам нужно добавить символ 4 раза, нужно использовать субтрактивную форму.
*
* Пример 1:
* Входные данные: num = 3749
* Выходные данные: "MMMDCCXLIX"
* Объяснение:
* 3000 = MMM = 1000 (M) + 1000 (M) + 1000 (M)
*  700 = DCC = 500 (D) + 100 (C) + 100 (C)
*   40 = XL на 10 (X) меньше чем 50 (L)
*    9 = IX на 1 (I) меньше чем 10 (X)
*
* Примечание: 49 не будет на 1 (I) меньше 50 (L),
* поскольку преобразование основано на десятичных знаках.
*
* Пример 2:
* Входные данные: num = 58
* Выходные данные: "LVIII"
* Объяснение:
* 50 = L
*  8 = VIII
*
* Пример 3:
* Входные данные: num = 1994
* Выходные данные: "MCMXCIV"
* Объяснение:
* 1000 = M
*  900 = CM
*   90 = XC
*    4 = IV
*
* Ограничения :
* 1 <= num <= 3999
*
*/

////////////////////////////////////////////////////////////////////////////////


