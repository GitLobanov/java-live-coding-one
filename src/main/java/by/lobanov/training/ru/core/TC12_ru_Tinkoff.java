package by.lobanov.training.ru.core;


import java.util.Scanner;

/**
 * <br>
 * Герман немного устал. Вот бы кто-нибудь сделал за него домашнее задание...
 * <br>
 * Задача, которую необходимо решить Герману, звучит следующим образом. Дана последовательность a1, a2, ... ,  и числа x, y, z.
 * <br>
 * Разрешается произвольное количество (в том числе ноль) раз выполнить следующую операцию: выбрать произвольное i (1 <= i <= n)
 * и увеличить ai на единицу.
 * <br>
 * Необходимо, чтобы хотя бы один элемент из последовательности делился на x, хотя бы один элемент делился на y и хотя бы один элемент делился на z.
 * Разрешается, чтобы для разных значений из набора (x,y,z) подходил один и тот же элемент из последовательности.
 * <br>
 * Помогите Герману отдохнуть перед сессией и найдите минимальное количество операций, которое необходимо выполнить, чтобы условие стало выполнено.
 * Формат входных данных
 * Первая строка содержит числа  n (1 <= n <= 2 * 10^5), x,y, и z.
 * Вторая строка содержит числа a1, a2, ... ,  an.
 * Формат выходных данных
 * Выведите одно число — минимальное количество операций, которое надо выполнить, чтобы для каждого из чисел x, y, z был хотя бы один элемент в последовательности, кратный данному числу.
 * Комментарий к примеру
 * В примере можно дважды увеличить a4 и один раз увеличить a5. Тогда на 10 будет делиться a4, на 20 будет делиться a5, на 30 будет делиться a4.
 * <br>
 * Input
 * 6 10 20 30
 * 8 17 5 28 39 13
 * Output
 * 3
 */
public class TC12_ru_Tinkoff {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Ввод данных
        int n = sc.nextInt();  // Количество элементов в массиве
        int x = sc.nextInt();  // Число x
        int y = sc.nextInt();  // Число y
        int z = sc.nextInt();  // Число z

        int[] a = new int[n];  // Массив a

        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        // Минимальные операции для x, y, z
        int minX = Integer.MAX_VALUE;
        int minY = Integer.MAX_VALUE;
        int minZ = Integer.MAX_VALUE;

        // Проходим по массиву и находим минимальное количество операций для каждого x, y, z
        for (int i = 0; i < n; i++) {
            // Для x
            int opX = (x - (a[i] % x)) % x;
            minX = Math.min(minX, opX);

            // Для y
            int opY = (y - (a[i] % y)) % y;
            minY = Math.min(minY, opY);

            // Для z
            int opZ = (z - (a[i] % z)) % z;
            minZ = Math.min(minZ, opZ);
        }

        // Суммируем минимальные операции для каждого из x, y, z
        int result = minX + minY + minZ;

        // Выводим результат
        System.out.println(result);
    }
}
